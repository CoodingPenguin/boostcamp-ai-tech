---
title: ⛺ DAY 04. 파이썬 기초 문법 III
date: 2021-01-21 20:08:00
category: "⛺ Boostcamp"
thumbnail: "./img/4-thumbnail.png"
draft: false
---

![thumbnail](./img/4-thumbnail.png)

> 🙌은 **QnA에 있는 질문-답변**을 통해 얻은 지식을 표시합니다.

## [👉 피어 세션](https://github.com/boostcamp-ai-tech-4/peer-session/issues/15)

### 질문

- [[펭귄] OrderedDict를 굳이 사용해야하는 상황이 있을까요?](https://github.com/boostcamp-ai-tech-4/peer-session/issues/13)
- [[샐리] split() 함수의 default 인자](https://github.com/boostcamp-ai-tech-4/peer-session/issues/14)

### 기록

- 오늘은 화요일에 나온 과제를 **코드리뷰**하는 시간을 가졌다. 사람마다 구현하는 방식이 달라서 코드 보는 재미가 쏠쏠했다.
- while문을 사용할 때 항상 `while True`로 해놓고 내부에 종료 조건을 넣었는데, 내가 모든 경우의 수를 헤아리지 않는다면 무한 루프에 빠질 수 있으므로 되도록이면 `while 조건문`으로 쓰자.

## Table of Contents

- [객체지향 프로그래밍](#객체지향-프로그래밍)
- [데코레이터](#데코레이터)
- [모듈](#모듈)
- [패키지](#패키지)
- [가상환경 설정](#가상환경-설정)
- [References](#references)

## 객제지향 프로그래밍

### 객체지향 프로그래밍이란?

객체는 **속성(attribute)**와 **행동(action)**으로 나타낼 수 있다. 이 개념을 프로그래밍에 적용한 것이 객체지향 프로그래밍이며, 속성은 **변수(variable)**로 행동은 **함수(method)**로 표현된다.

파이썬에서 객체는 **클래스(class)**를 이용해서 구현할 수 있다.

- 클래스는 객체의 청사진과 같은 역할을 한다.

```python
class Animal():
  def __init__(self, species, age):
    self.species = species
    self.age = age

  def run(self):
    print(f"{self.species} is running...")
```

- 클래스를 선언하면 인스턴스(객체)를 생성한다.

```python
dog = Animal("Dog", 3)
dog.run()   # Dog is running...
```

### 객체 지향 언어의 특징

#### 상속 (Inheritance)

부모클래스로부터 **속성과 메서드를 물려 받은 자식 클래스**를 생성하는 것

- 자식 클래스는 부모클래스에 정의된 속성과 메서드를 사용할 수 있다.
- 함수 재정의로 자식 클래스에 맞게 함수를 변형할 수 있다.
- `super()`로 부모클래스를 불러오거나 부모클래스의 함수를 사용할 수 있다.

```python
class Dog(Animal):
  def __init__(self, species, age, breed):
    super().__init__(species, age)
    self.breed = breed

  def run(self):
    super().run()
    print(f"The breed of {self.species} is {self.breed}.")
```

```python
siba = Dog("Dog", 3, "siba")
siba.run()
# Dog is running...
# The breed of Dog is siba.
```

#### 다형성 (Polymorphism)

같은 이름 메서드의 내부 로직을 다르게 작성할 수 있는 것을 말한다. 주로 부모클래스의 상속받은 자식 클래스가 **함수를 재정의**하면서 발생한다.

<div class="quote-block">
<div class="quote-block__emoji">💡</div>
<div class="quote-block__content" markdown=1>

덕 타이핑

파이썬은 다형성을 느슨하게 구현했기 때문에 클래스에 상관 없이 같은 동작(=메서드)을 한다면 같은 타입으로 간주한다. "꽥꽥하면 오리이다"라는 말에서 유래해 이를 **덕 타이핑 (Duck Typing)**이라고 부른다.

</div>
</div>

#### 가시성 (Visibility)

객체의 속성의 이름 바로 앞에 `__`을 붙이면 속성을 숨길 수 있다. 접근을 하면 에러가 발생한다.

속성에 직접 접근할 수 없지만 간접적으로 접근은 가능하다. **Getter-Setter 메서드**를 직접 정의하거나 `@property`나 `@함수이름.setter`같은 **데코레이터(decorator)**로 정의하여 접근할 수 있다.

- 직접 Getter-Setter 메서드 정의

```python
class Person():
  def __init__(self, name)
    self.name = name

  def get_name(self):
    return self.name

  def set_name(self, new_name):
    self.name = new_name
```

```python
groot = Person("Groot")
print(groot.get_name())   # Groot
groot.set_name("Groooot")
print(groot.get_name())   # Groooot
```

- 데코레이터로 Getter-Setter 구현

```python
class Person():
  def __init__(self, name)
    self.name = name

  @property
  def name(self):
    return self.name

  @name.setter
  def name(self, new_name):
    self.name = new_name
```

```python
groot = Person("Groot")
print(groot.name)   # Groot
groot.name = "Groooot"
print(groot.name)   # Groooot
```

## 데코레이터

### 알아야할 용어

#### 일급 객체 (First-class Object)

파이썬은 함수를 `일급 객체`로 취급한다. 즉, 리스트, 딕셔너리처럼 함수를 함수의 인자로 넘기거나 함수 자체를 반환할 수 있다.

#### 중첩 함수 (Inner Function)

파이썬은 **함수 내에 또 다른 함수를 정의**하는 것이 가능하다. 다만, 함수 외부에서 중첩 함수를 호출하는 것은 불가능하다. 중첩 함수는 다음과 같은 장점을 가진다:

- `장점 1` global scope로 부터 중첩 함수를 보호할 수 있다. (=encapsulation)
- `장점 2` 중첩 함수의 본 역할을 확실시하고 자잘한 에러 처리는 중첩 함수 밖에서 처리할 수 있다.
- `장점 3` 클로저(Closure) 혹은 팩토리(Factory) 함수의 구현이 가능하다.
  - 여기서 클로저란 함수가 선언 시의 상태(state)를 기억했다가 나중에 호출될 때 **해당 상태에 따라 수행하는 함수**를 말한다.

### 데코레이터는 뭐지?

데코레이터는 다른 함수를 가져와 해당 함수를 **변형하지 않고 기능 확장시킨 함수**를 반환한다. 이름 그대로 원 함수는 유지하고 기능을 추가하여 꾸미는 것이다!

- 한 함수에 여러 개의 데코레이터를 씌울 수 있다. 가장 바깥 Wrapper는 가장 위쪽에 있는 데코레이터이다.
- 데코레이터로 구현된 예시로 `globals()`이 있다.

### 데코레이터 구현

데코레이터 함수를 정의하고 꾸밀 함수 위에 `@데코레이터_함수_이름`을 써주면 된다. 자세한 내용은 [Real Python - Primer on Python Decorators](https://realpython.com/primer-on-python-decorators/#syntactic-sugar)을 참고하자!

#### 가장 대표적인 구현

```python
# 데코레이터 함수 정의
import functools

def name(func):
    @functools.wraps(func)              # 꾸밀 함수의 정체성 확보
    def wrapper_name(*args, **kwargs):  # 꾸밀 함수의 인수 전달
        print("Before calling")
        value = func(*args, **kwargs)
        print("After calling")
        return value                    # 꾸밀 함수의 반환값
    return wrapper_name
```

```python
# say_hello 함수 꾸미기
@name
def say_hello(name):
  print(f"Hi, my name is {name}.")
  return f"{name}'s love"

gift = say_hello("Groot")
print(gift)

```

<details markdown="1">
<summary><strong>👀 실행 결과 보기</strong></summary>

```
# Before calling
# Hi, my name is Groot.
# After calling
# Groot's love
```

</details>

#### 인수를 받는 데코레이터 구현

`say_hello("Groot")`를 호출하는 것은 `(name("==Introduction=="))(say_hello)("Groot")`와 같다.

```python
# 데커레이터 함수 꾸미기
import functools

def name(arg):
  def decorator_name(func):
    @functools.wraps(func)                # 꾸밀 함수의 정체성 확보
    def wrapper_name(*args, **kwargs):    # 꾸밀 함수의 인수 전달
        print(arg)                        # 데코레이터 인수 사용
        print("Before calling")
        value = func(*args, **kwargs)
        print("After calling")
        return value                      # 꾸밀 함수의 반환값
    return wrapper_name
  return decorator_name
```

```python
# say_hello 함수 꾸미기
@name("==Introduction==")
def say_hello(name):
  print(f"Hi, my name is {name}.")
  return f"{name}'s love"

gift = say_hello("Groot")
print(gift)
```

<details markdown="1">
<summary><strong>👀 실행 결과 보기</strong></summary>

```
# ==Introduction==
# Before calling
# Hi, my name is Groot.
# After calling
# Groot's love
```

</details>

## 모듈

파이썬의 모듈은 `.py` 파일을 말한다. `import` 문을 사용해서 모듈을 호출할 수 있다.

<div class="quote-block">
<div class="quote-block__emoji">💡</div>
<div class="quote-block__content" markdown=1>

\_\_pycache\_\_

인터프리터가 파이썬 파일을 쉽게 호출할 수 있도록 기계어로 번역한 후의 파일이 저장되는 공간이다. 다음 실행 시 좀 더 빨리 파일을 불러올 수 있다.

</div>
</div>

### 다양한 import 예시

- `import module as m`: module을 m으로 별칭을 설정
- `from module import func[class]`: module의 특정 함수 혹은 클래스 호출
- `from module import *`: module 안에 있는 모든 함수와 클래스를 호출

### if \_\_name\_\_ == "\_\_main\_\_"

모듈도 결국 **파이썬 스크립트**이다. 그러므로 실행을 하면 다른 스크립트와 똑같이 실행될 것이다. 그런데 만약 모듈에 함수 테스트를 위해 여러 `print()` 문을 적었다고 생각해보자.

다른 파일에서 해당 모듈을 import하면 어떻게 될까? **모듈도 스크립트이기 때문에 테스트용으로 써놓은 코드가 import할 때 실행이 될 것이다.** 그럼 import 할 때마다 출력이 되서 참 곤란할 것이다. 이를 방지하기 위해 테스트용 코드를 `if __name__ == "__main__"` 안에 넣으면 모듈 import 시에는 모듈 파일을 실행하는 것이 아니므로 테스트용 코드를 실행하지 않는다.

## 패키지

여러 다양한 모듈들의 묶어 패키지로 만들 수 있다. 이 때 `__init__`, `__main__`과 같은 키워드 파일명이 사용된다. 대부분의 오픈소스가 패키지로 관리되고 있다.

### \_\_init\_\_.py

현재 폴더가 패키지임을 알리는 초기화 스크립트

- Python3.3부터는 이 파일이 없더라도 패키지로 간주한다.
- `__all__` 로 import할 수 있는 모듈을 정의하고 `import`로 해당 모듈들을 불러온다.

```python
__all__ = ["sound", "character", "manager"]

from . import sound
from . import character
from . import manager
```

### \_\_main\_\_.py

패키지를 실행시키는, 즉 **실행의 시작점**이 되는 파일

```python
from character import move_character()
from sound import play_bgm()
from manager import start_game()

if __name__ == '__main__':
  start_game()
  play_bgm()
  move_character()
```

## 가상환경 설정

프로젝트 진행 시 여러 개의 가상환경을 만들어 **패키지를 관리**할 수 있다. 보통 다음과 같은 2가지 도구를 사용한다.

- `virtualenv + pip`: 가장 대표적인 가상환경 관리 도구 **(Mac, Linux)**
- `conda`: 상용 가상환경도구로 컴파일된 C라이브러리를 제공 **(Windows)**

## References

- [Python Modules and Packages – An Introduction](https://realpython.com/python-modules-packages/)
- [Primer on Python Decorators](https://realpython.com/primer-on-python-decorators/)
- [Python Inner Functions—What Are They Good For?](https://realpython.com/inner-functions-what-are-they-good-for/)
