---
title: ⛺ DAY 03. 파이썬 기초 문법 II
date: 2021-01-20 13:44:00
category: "⛺ Boostcamp"
thumbnail: "./img/3-thumbnail.png"
draft: false
---

![thumbnail](./img/3-thumbnail.png)

> 🙌은 **QnA에 있는 질문-답변**을 통해 얻은 지식을 표시합니다.

## [👉 피어 세션](https://github.com/boostcamp-ai-tech-4/peer-session/issues/12)

### 질문

- [[펭귄] set의 요소 제거 메서드 remove와 discard의 차이](https://github.com/boostcamp-ai-tech-4/peer-session/issues/9)
- [[히스] Generator 코드의 yield](https://github.com/boostcamp-ai-tech-4/peer-session/issues/10)
- [[후미] 언제 메모리를 고려해야 할까?](https://github.com/boostcamp-ai-tech-4/peer-session/issues/11)

### 기록

- 과제 코드를 구현할 때 시간복잡도를 딱히 생각하지 않고 짰는데 이제부터는 **성능을 생각하면서 짜야겠다**.
- **조교님(Jerry님)🐹**과의 QnA 시간을 가졌다. 질문을 생각해놓지를 않아서 질문을 못했는데 다음에는 질문을 미리 준비해야겠다.

## Table of Contents

- [기본 자료구조](#기본-자료구조)
- [Collections 모듈](#collections-모듈)
- [List Comprehension](#list-comprehension)
- [Generator](#generator)
- [Asterisk \*](#asterisk-)
- [References](#references)

## 기본 자료구조

- **리스트**: 리스트의 `append`와 `pop`을 사용해 스택과 큐 구현
- **튜플**: 값 변경이 불가능하므로 사용자 실수에 의한 에러를 사전에 방지
- **집합**: `union`, `intersection`, `difference`와 같은 메서드를 사용해 댜앙한 집합 연산이 가능
- **딕셔너리**: 특정 value를 key로 구분할 때 사용

## Collections 모듈

### deque

스택과 큐를 지원하는 모듈로, 메모리에 있어서 리스트에 비해 효율적이다. 예를 들면, 가장 앞의 요소를 `pop`을 할 때, 덱은 $O(1)$이지만 리스트는 요소의 인덱스를 다시 계산해야 하므로 $O(n)$이다.

#### 인수 maxlen

`maxlen`을 지정하면 덱은 최대 길이를 초과하여 덱을 확장시키지 않는다. 새로운 요소가 들어오면 가장 오래된 요소를 버리고 새로운 요소를 받는다.

```python
from collections import deque
dq = deque(maxlen=3)    # 최대 크기를 3으로 지정
for i in range(50):
    dq.append(i)
print(dq)   # [47, 48, 49]
```

#### 연결리스트의 특징 지원

- `rotate(n=1)`: $n$만큼 오른쪽으로 회전한다. $n$이 음수면, 왼쪽으로 회전한다.
- `reverse()`: 요소의 순서를 뒤집는다.

```python
from collections import deque
dq = deque([1, 2, 3, 4, 5])
dq.rotate(2)    # [4, 5, 1, 2, 3]
dq.rotate(-2)   # [1, 2, 3, 4, 5]
dq.reverse()    # [5, 4, 3, 2, 1]
```

### OrderedDict와 DefaultDict

- `OrderedDict`: PEP468가 인정되면서 딕셔너리의 순서가 보장되면서 잘 쓰이지 않게 되었다.
- `defaultDict`: 딕셔너리 요소 생성 시 초기값을 지정할 수 있다.

### Counter

시퀀스 데이터의 요소를 key, 요소의 개수를 value로 가진 딕셔너리 서브 크래스이다. `+`, `-`, `&`, `|` 연산으로 **더하기, 빼기, 교집합, 합집합 연산**을 할 수 있다.

```python
from collections import Counter
counter1 = Counter("abcdabcd")  # {'a':2, 'b':2, 'c':2, 'd':2}
counter2 = Counter("cddec")   # {'c':2, 'd':2, 'e':1}

counter1+counter2   # {'c': 4, 'd': 4, 'a': 2, 'b': 2, 'e': 1}
counter1-counter2   # {'a': 2, 'b': 2}
counter1&counter2   # {'c': 2, 'd': 2}
counter1|counter2   # {'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 1}
```

### namedtuple

튜플 형태로 데이터 구조체를 저장하는 방식

```python
from collections import namedtuple
Point = namedtuple('Point', 'x y')
p = Point(x=10, y=20)
print(p[0], p[1])   # 인덱스로 접근
print(p.x, p.y)     # 데이터 변수로 접근
```

<div class="quote-block">
<div class="quote-block__emoji">💡</div>
<div class="quote-block__content" markdown=1>

namedtuple vs dataclass vs attrs

[이것](https://glyph.twistedmatrix.com/2016/08/attrs.html)을 보고 namedtuple, dataclass, attrs를 비교하면서 어떤 것이 더 좋을지 생각해보자

</div>
</div>

## List Comprehension

루프문을 쓰는 것보다 빠르므로 루프문보다는 **리스트 컨프리헨션을 애용**하자!

### 조건이 삼항연산자라면?

리스트 컨프리헨션에서 조건으로 삼항 연산자를 쓴다면 이때는 조건문이 뒤가 아니라 앞으로 온다.

```python
nums = [1, 2, 3, 4, 5]
only_odd = [i for i in nums if nums%2]              # [1, 3, 5]
odd_mask= [True if nums%2 else False for i in nums] # [True, False, True, False, True]
```

### 중첩 루프와 zip

리스트 컨프리헨션에서 2개의 for문을 쓰는 것은 중첩 루프(nested loop)를 쓰는 것과 같다. 앞에 위치아 for문이 가장 바깥쪽 루프가 된다.

`zip`은 2개의 리스트를 받아 병렬적으로 요소 1개씩 뽑아내는 것이다.

```python
nums = ['1', '2']
alphas = ['a', 'b']

nested_loop_list = [i+j for i in nums for j in alphas]  # ['1a', '1b', '2a', '2b']
zip_list = [i+j for i, j in zip(nums, alphas)]  # ['1a', '2b']
```

## Generator

### Iterable vs Iterator

- `Iterable 객체`: iter 함수에 인자로 전달 가능한, 반복 가능한 객체
  - 예를 들면, 리스트, 딕셔너리, 집합, 문자열 등이 있다.
- `Iterator 객체`: iter 함수가 생성해서 반환하는 객체
  - next 함수로 Iterable 객체의 요소의 값을 차례대로 반환한다.
  - 만약 Iterable 객체를 모두 돌면 **StopIteration** 예외를 발생시킨다.
  - 다시 돌고 싶다면 iter 함수르 Iterator 객체를 다시 생성해야 한다.

### Generator가 뭘까?

Iterator 객체를 간단히 만들 수 있는 함수를 말한다. 제너레이터는 다음과 같이 **① yield문과 함수, ② 표현식 형태**로 만들 수 있다.

#### 방법 1. yield문과 함수

제너레이터에 `next()`가 호출될 때마다 제너레이터는 멈추기 전 어디를 실행했는지를 기억해 거기서부터 실행을 다시 시작한다. `yield`를 써서 **무엇을 반환하고 어디서 멈출 것인지** 표시를 해준다.

- 제너레이터 함수 정의

```python
def generator_list(value):
    for i in range(value):
        # 값을 반환하고 여기를 기억
        yield i
```

- 제너레이터 객체 생성 및 next 함수로 호출

```python
gen = generator_list(2)
print(next(gen))    # 0
print(next(gen))    # 1
print(next(gen))    # StopIteration 에러 발생
```

#### 방법 2. 표현문

`()`를 써서 리스트 컴프리헨션처럼 작성해주면 된다.

```python
value = 2
gen = (i for i in range(value))
print(next(gen))    # 0
print(next(gen))    # 1
print(next(gen))    # StopIteration 에러 발생
```

### 리스트보다는 제너레이터!

리스트를 사용하면 리스트의 크기만큼 메모리에 공간이 할당된다. 반면 제너레이터는 말그대로 **next 함수로 호출될 때 값을 생성하고 해당 값만 메모리에 올린다!** 즉, 메모리를 절약할 수 있다.

작은 데이터라면 상관없지만 큰 데이터에서는 **제너레이터 사용이 필수**이다. 몇 GB 데이터를 메모리에 올릴 수 없지 않은가? 그러므로 단순 리스트를 반환하기보다는 제너레이터를 써보는 건 어떨까?

🙌질문게시판의 질문 중에 데이터전처리 과정에서 `apply` 함수를 사용했는데 데이터의 크기가 너무 커서 **Out-of-Memory**가 났는데 이에 대한 해결책을 묻는 질문이 있었다. 튜터님의 답변에 따르면 <u>제너레이터를 사용하여 매 Iteration마다 전치리 결과를 뱉어주는 함수를 만들고 그 결과를 바로 문서로 저장</u>한다고 한다. 나중에 데이터가공할 때 데이터가 크면 한 번 고려해봐야겠다! 참고로 Pytorch의 `dataloader`도 제너레이터로 구현되어 있다고 한다.

## Asterisk \*

### 가변인자와 키워드 가변인자

- `가변인자` **(\*args)**: 일반 인자 다음에 오는 인자로, 일반 인자 이후의 모든 인자를 **튜플**로 묶는다.
- `키워드 가변인자` **(\*\*kwargs)**: 가변인자 다음에 오는 인자로, 키워드 인자의 형태로 인자를 추가하면 **딕셔너리**로 묶는다.

<div class="quote-block">
<div class="quote-block__emoji">💡</div>
<div class="quote-block__content" markdown=1>

함수의 인자 순서

함수의 인자는 **일반 인자 - 가변 인자 - 키워드 가변 인자** 순서를 꼭 지켜야한다! 아니면 에러가 발생한다!

</div>
</div>

### 언패킹

튜플, 리스트, 문자열, 딕셔너리에 있는 값을 **함수 인자**나 **zip** 등에서 언패킹하는 데도 사용된다.

- 함수 일반 인자

```python
list_packed = [1, 2, 3, 4, 5]
print(*list_packed, sep="-")    # 1-2-3-4-5
tuple_packed = (1, 2, 3, 4, 5)
print(*tuple_packed, sep="-")   # 1-2-3-4-5
str_packed = "abcdef"
print(*str_packed, sep="-")     # a-b-c-d-e-f
```

- 함수 키워드 인자

> 💡 잘 모르겠다면 자바스크립트의 `...` 연산자를 떠올려보자!

```python
def print_info(name, year, is_adult):
    print(f"My name is {name} and {year} years old!", end=" ")
    if is_adult:
        print("I'm an adult!")
    else:
        print("I'm not an adult!")


my_info = {'name': 'Groot', 'year': 20, 'is_adult': False}
print_info(**my_info)
# My name is Groot and 20 years old! I'm not an adult!
```

## References

- [The One Python Library Everyone Needs](https://glyph.twistedmatrix.com/2016/08/attrs.html)
- [Iterable과 Iterator](https://wikidocs.net/16068)
- [Generator (제너레이터)](https://wikidocs.net/16069)
- [윤성우의 열혈 파이썬 중급편](http://www.yes24.com/Product/Goods/81519650)
- [파이썬 코딩의 기술](http://www.yes24.com/Product/Goods/94197582)
- [Python Documentation - collections](https://docs.python.org/ko/3/library/collections.html?highlight=collections#module-collections)
- [Python Documentation - 제너레이터](https://docs.python.org/ko/3/tutorial/classes.html?highlight=%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0#generators)
